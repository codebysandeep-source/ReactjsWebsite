{"ast":null,"code":"var style = require('./');\n\nexports.printError = printError;\n\nfunction printError(error) {\n  colourError(error, false);\n}\n\nexports.parseStackLine = parseStackLine;\n\nfunction parseStackLine(row) {\n  var regex = /^\\s*?at\\s+([\\w\\.\\-\\_\\<\\>]*)?\\s*\\(?([\\[\\ \\]\\/\\-\\_\\w\\.]+)/g; //\n\n  lines = /.*?\\:(\\d+)\\:(\\d+)/, m = regex.exec(row), ln = lines.exec(row), line = {};\n\n  if (m) {\n    line = {\n      function: m[1],\n      file: m[2],\n      line: ln ? 1 * ln[1] : undefined,\n      column: ln ? 1 * ln[2] : undefined\n    };\n  }\n\n  line.unmatched = row;\n  return line;\n}\n\nexports.parseError = parseError;\n\nfunction parseError(error) {\n  var obj;\n  /*  if(!error)\n      return style('' + error).red\n  */\n\n  obj = {\n    name: 'object' == typeof error && error != null ? error.name || error.constructor.name : 'thrown'\n  };\n\n  if (error && error.stack) {\n    var stack = stackStr = error.stack.split(\"\\n\");\n    obj.stack = stack.map(parseStackLine);\n  } else {\n    obj.message = error && error.message || '' + error;\n    obj.stack = [{\n      unmatched: '[no stack trace]'\n    }]; // same format as a propper error, so printing is easy\n  }\n\n  return obj;\n}\n\nexports.styleError = colourError;\n\nfunction colourError(error, enable) {\n  style = style.enable(enable === false ? false : true);\n  var s = parsed = parseError(error);\n  s = style(parsed.name).red.bold + \": \" + (parsed.message ? style(parsed.message).yellow.bold : \"\");\n  s += \"\\n\";\n  s += parsed.stack.map(function (row) {\n    if (row.file) {\n      var file = row.file.replace(process.env.NODE_PATH, '$');\n      return style(style(\" \" + row.function).yellow.rpad(30, style('.').grey) + \" \" + style(file).white.bold).rpad(70, style('.').grey) + style(row.line || '?').lpad(3, style('.').grey).cyan + \":\" + style(row.column || '?').lpad(3, style('.').grey).magenta;\n    }\n\n    return row.unmatched;\n  }).join(\"\\n\") + \"\\n\"; //+ end\n  //console.log(s)\n\n  return s;\n}","map":{"version":3,"sources":["C:/Users/Sandeep/Desktop/Reactjs/node_modules/style/error.js"],"names":["style","require","exports","printError","error","colourError","parseStackLine","row","regex","lines","m","exec","ln","line","function","file","undefined","column","unmatched","parseError","obj","name","constructor","stack","stackStr","split","map","message","styleError","enable","s","parsed","red","bold","yellow","replace","process","env","NODE_PATH","rpad","grey","white","lpad","cyan","magenta","join"],"mappings":"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","sourcesContent":["var style = require('./');\n\nexports.printError = printError\nfunction printError(error){\n  colourError(error,false)\n}\n\nexports.parseStackLine = parseStackLine\nfunction parseStackLine (row){\n  var regex = /^\\s*?at\\s+([\\w\\.\\-\\_\\<\\>]*)?\\s*\\(?([\\[\\ \\]\\/\\-\\_\\w\\.]+)/g //\n      lines = /.*?\\:(\\d+)\\:(\\d+)/\n    , m = regex.exec(row)\n    , ln = lines.exec(row)\n    , line = {}\n  if (m){\n   line = { function: m[1]\n    , file: m[2]\n    , line: (ln ? 1 * ln[1] : undefined)\n    , column:  (ln ? 1 * ln[2] : undefined) } } \n    \n  line.unmatched = row\n  return line    \n}\n\nexports.parseError = parseError\nfunction parseError(error){\n  var obj\n\n/*  if(!error)\n    return style('' + error).red\n*/\n  obj = \n    { name: ('object' == typeof error && error != null) ? (error.name || error.constructor.name) : 'thrown'\n    }\n    if(error && error.stack){\n      var stack = stackStr = error.stack.split(\"\\n\")\n      obj.stack = stack.map(parseStackLine)\n    } else {\n      obj.message = (error && error.message) || '' + error \n      obj.stack = [{unmatched: '[no stack trace]'}] // same format as a propper error, so printing is easy\n    }\n  return obj\n}\n\nexports.styleError = colourError\nfunction colourError(error,enable){\n  \n  style = style.enable(enable === false ? false : true)\n  var s = parsed = parseError(error)\n  \n  s = style(parsed.name).red.bold + \": \" + (parsed.message ? style(parsed.message).yellow.bold : \"\")\n  s += \"\\n\"\n  s += parsed.stack.map(function (row){\n    if(row.file){\n      var file = row.file.replace(process.env.NODE_PATH,'$')\n\n      return style(style(\" \" + row.function).yellow.rpad(30,style('.').grey)\n          + \" \"\n          + style(file).white.bold).rpad(70,style('.').grey)\n        + style(row.line || '?').lpad(3,style('.').grey).cyan\n        + \":\"\n        + style(row.column || '?').lpad(3,style('.').grey).magenta\n    }\n    return (row.unmatched)\n  }).join(\"\\n\") + \"\\n\" //+ end\n  \n  //console.log(s)\n  return s\n}\n"]},"metadata":{},"sourceType":"script"}